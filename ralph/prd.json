[
	{
		"category": "functional",
		"description": "Rust - Create tracing types and data structures",
		"steps": [
			"Create src-tauri/src/tracing/ directory",
			"Create types.rs with: LogLevel enum (debug, info, warn, error, trace_end)",
			"Add LogEntry struct with ts, trace, level, msg, ctx, err, duration_ms, status fields",
			"Add TraceError struct with message (String) and code (&'static str) fields",
			"Use serde with skip_serializing_if for optional fields (err, duration_ms, status)",
			"Use short field names (ts, msg, ctx) to keep log lines compact",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "All fields use short names for compact JSON. LogLevel uses lowercase serialization (debug, info, etc). TraceError code is &'static str for zero-copy error codes."
	},
	{
		"category": "functional",
		"description": "Rust - Implement LogWriter with buffered channel",
		"steps": [
			"Create writer.rs module",
			"Create LogWriter struct with mpsc::Sender<LogEntry>",
			"Implement spawn() that creates channel and spawns writer thread",
			"Writer thread: buffer Vec<LogEntry> with capacity 32",
			"Implement recv_timeout(100ms) loop for non-blocking receive",
			"Flush buffer when: buffer.len() >= 32 OR 100ms elapsed since last flush",
			"flush_buffer(): get today's date, open file in append mode, write each entry as JSON line",
			"Handle RecvTimeoutError::Disconnected for graceful shutdown (final flush)",
			"Implement send(&self, entry: LogEntry) as fire-and-forget",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "File path: ~/.local/share/jubby/logs/traces/YYYY-MM-DD.jsonl. Use chrono::Local for date. OpenOptions with create(true).append(true). Buffer prevents excessive file I/O."
	},
	{
		"category": "functional",
		"description": "Rust - Implement ContextGuard with RAII",
		"steps": [
			"Create guard.rs module",
			"Create ContextGuard struct holding Arc<Trace>",
			"Implement Drop trait that calls trace.pop_context()",
			"Guard must be Send + Sync for async compatibility",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "RAII pattern ensures context is always removed when guard goes out of scope, even on panic/early return. The Arc<Trace> reference allows the guard to be moved across await points."
	},
	{
		"category": "functional",
		"description": "Rust - Implement Trace struct core",
		"steps": [
			"Create trace.rs module",
			"Create Trace struct with: id (String), started_at (Instant), context (RwLock<Vec<Value>>), writer_tx (Sender<LogEntry>), has_error (AtomicBool)",
			"Implement generate_trace_id() -> String using format!(\"{:08x}\", rand::random::<u32>())",
			"Implement new() that creates trace with generated ID and gets writer from global",
			"Implement continue_from(id: String) for frontend trace continuation",
			"Implement with(key, value) builder pattern that adds to initial context",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Use RwLock for context stack (multiple readers, single writer). AtomicBool for has_error avoids lock contention. Trace is Send + Sync for async usage."
	},
	{
		"category": "functional",
		"description": "Rust - Implement Trace context methods",
		"steps": [
			"Implement push(&self, ctx: Value) -> ContextGuard that adds context to stack",
			"Implement pop_context(&self) that removes last context from stack (called by ContextGuard::drop)",
			"Implement merged_context(&self) -> Value that merges all context stack into single object",
			"Merged context: later values override earlier ones for same key",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "push() acquires write lock, adds context, returns ContextGuard. merged_context() acquires read lock, iterates stack merging into single Value::Object."
	},
	{
		"category": "functional",
		"description": "Rust - Implement Trace logging methods",
		"steps": [
			"Implement emit(&self, level: LogLevel, msg: &str, err: Option<TraceError>)",
			"emit() creates LogEntry with current timestamp (ISO 8601), trace id, level, msg, merged context, err",
			"Sends entry to writer via channel (fire-and-forget)",
			"If err.is_some(), set has_error to true",
			"Implement debug(&self, msg: &str), info(&self, msg: &str), warn(&self, msg: &str)",
			"Implement error(&self, msg: &str, err: TraceError)",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Timestamp format: chrono::Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true). Convenience methods just call emit() with appropriate LogLevel."
	},
	{
		"category": "functional",
		"description": "Rust - Implement Trace Drop for trace_end",
		"steps": [
			"Implement Drop trait for Trace",
			"On drop: calculate duration_ms from started_at.elapsed()",
			"Determine status: 'error' if has_error is true, 'ok' otherwise",
			"Emit trace_end entry with duration_ms and status fields",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": true,
		"notes": "trace_end is automatically emitted when Trace goes out of scope. This ensures every trace has a summary even if code panics (Drop still runs)."
	},
	{
		"category": "functional",
		"description": "Rust - Implement cleanup for old logs",
		"steps": [
			"Create cleanup.rs module",
			"Implement cleanup_old_traces() function",
			"Get traces directory path: ~/.local/share/jubby/logs/traces/",
			"Calculate cutoff date: today - 1 day",
			"Iterate directory entries, parse date from filename (YYYY-MM-DD.jsonl)",
			"Delete files where date < cutoff",
			"Handle errors gracefully (log warning, continue)",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Runs once on app startup. Simple string comparison works for YYYY-MM-DD format. Don't fail app startup if cleanup fails."
	},
	{
		"category": "functional",
		"description": "Rust - Create mod.rs and init_tracing()",
		"steps": [
			"Create mod.rs with pub use for Trace, ContextGuard, TraceError, LogLevel",
			"Use once_cell::sync::OnceCell for global LOG_WRITER",
			"Implement init_tracing() that: creates traces directory, runs cleanup, spawns LogWriter, stores in OnceCell",
			"Implement get_writer() -> &'static LogWriter for internal use",
			"Add tracing module to src-tauri/src/main.rs or lib.rs",
			"Call init_tracing() in app setup before other initialization",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "OnceCell ensures single initialization. get_writer() panics if called before init (programming error). Directory: fs::create_dir_all for nested path creation."
	},
	{
		"category": "functional",
		"description": "Rust - Add required dependencies",
		"steps": [
			"Add to Cargo.toml: once_cell (for global state)",
			"Add rand (for trace ID generation) if not present",
			"Verify chrono is available (already used in project)",
			"Verify serde_json is available (already used)",
			"Run cargo check"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Check existing Cargo.toml before adding - some deps may already exist. Use workspace versions if applicable."
	},
	{
		"category": "functional",
		"description": "Rust - Integration test with existing command",
		"steps": [
			"Pick one simple existing Tauri command to add tracing",
			"Create Trace at command start with plugin and action context",
			"Add trace.info() call at key points",
			"Add trace.push() for sub-operations if applicable",
			"Verify trace_end is emitted when command completes",
			"Run cargo check",
			"Test manually: run command, check ~/.local/share/jubby/logs/traces/*.jsonl"
		],
		"shouldCommit": true,
		"passes": true,
		"notes": "Choose a command that's easy to trigger manually. This validates the full flow before wider adoption. Check file contains valid JSON lines."
	},
	{
		"category": "functional",
		"description": "TypeScript - Create trace types",
		"steps": [
			"Create src/lib/trace.ts",
			"Define TraceContext interface: Record<string, string | number | boolean>",
			"Define TraceError interface: { message: string; code: string }",
			"Define Trace interface with: id, push, debug, info, warn, error, end, Symbol.dispose",
			"Run bun tsc --noEmit"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Symbol.dispose enables TS 5.2+ 'using' keyword for automatic cleanup. Keep types simple - frontend tracing is lighter than backend."
	},
	{
		"category": "functional",
		"description": "TypeScript - Implement createTrace and Trace class",
		"steps": [
			"Implement generateTraceId(): 8 hex chars using Math.random",
			"Implement createTrace(initialContext?: TraceContext): Trace",
			"Create TraceImpl class with: id, contextStack, startedAt, hasError",
			"Implement push(ctx): add to stack, return cleanup function",
			"Implement debug/info/warn/error methods that log to console (dev) or invoke backend (prod)",
			"Implement end() that logs trace_end with duration",
			"Implement Symbol.dispose that calls end()",
			"Run bun tsc --noEmit"
		],
		"shouldCommit": true,
		"passes": true,
		"notes": "For now, frontend logs to console.log with structured format. Backend invoke for logging can be added later if needed. The 'using' cleanup ensures traces always end."
	},
	{
		"category": "functional",
		"description": "TypeScript - Add trace propagation to invoke wrapper",
		"steps": [
			"Create typesafe invoke wrapper or extend existing pattern",
			"When trace exists, add trace_id to invoke payload",
			"Document pattern for using trace with backend calls",
			"Run bun tsc --noEmit"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Pattern: invoke('cmd', { trace_id: trace.id, ...params }). Backend can continue_from(trace_id) to link frontend and backend traces."
	},
	{
		"category": "functional",
		"description": "TypeScript - Integration test with existing component",
		"steps": [
			"Pick one simple user action to add tracing",
			"Create trace at action start",
			"Add trace.info() at key points",
			"Use push() for sub-operations",
			"Ensure trace.end() or 'using' cleanup",
			"Run bun tsc --noEmit",
			"Test manually: trigger action, check browser console for trace logs"
		],
		"shouldCommit": true,
		"passes": false,
		"notes": "Choose an action that also calls backend to test full frontendâ†’backend trace flow. Verify trace_id appears in both frontend console and backend jsonl."
	},
	{
		"category": "test",
		"description": "Manual testing - Full flow verification",
		"steps": [
			"Verify cargo check passes",
			"Verify bun tsc --noEmit passes",
			"Trigger traced action from frontend",
			"Check browser console for frontend trace logs with trace_id",
			"Check ~/.local/share/jubby/logs/traces/YYYY-MM-DD.jsonl exists",
			"Verify jsonl contains valid JSON lines with matching trace_id",
			"Verify trace_end entry exists with duration_ms and status",
			"Verify context accumulates correctly through push/pop",
			"Test error path: trigger an error, verify has status='error'",
			"Test cleanup: create old log file, restart app, verify deleted",
			"Test concurrent traces: trigger multiple actions, verify separate trace_ids"
		],
		"shouldCommit": false,
		"passes": false,
		"notes": "Full end-to-end validation. Document any issues found for follow-up fixes."
	}
]

[
  {
    "category": "functional",
    "description": "Create typed error hierarchy (eliminate string-based error detection)",
    "steps": [
      "Create PortalError enum with variants: Unavailable, UserCancelled, TokenInvalid, SessionFailed(String), Timeout(Duration)",
      "Create CaptureError enum with variants: InitFailed, StreamFailed, NoFrames, FormatNegotiationFailed, MainloopTimeout, WriterStalled, WriterDisconnected",
      "Create EncodingError enum with variants: FfmpegNotFound, ProcessFailed { exit_code, stderr }, WriteFailed, Timeout(Duration)",
      "Refactor QuickClipError to use #[from] for automatic conversions from sub-errors",
      "Add is_recoverable_with_retry() method to PortalError for token retry logic",
      "Remove all string-based error detection (contains('cancelled')) from session.rs"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read errors.rs and session.rs first. The goal is to make error handling typed and exhaustive. Use thiserror for all enums."
  },
  {
    "category": "functional",
    "description": "Implement RecordingState enum state machine",
    "steps": [
      "Create RecordingState enum with variants: Idle, Starting { started_at }, Recording { started_at, frame_count, resolution }, Stopping { started_at, stop_requested_at }, Failed { error, recoverable }",
      "Create RecordingEvent enum with all possible events (StartRequested, StopRequested, PortalReady, CaptureFailed, etc.)",
      "Create SideEffect enum for effects triggered by transitions (InitiatePortal, SignalStop, EmitStateChange, Cleanup, SaveRecording)",
      "Implement transition() as pure function: (State, Event) -> (NewState, Vec<SideEffect>)",
      "Ensure invalid transitions return current state with empty effects (no panic)",
      "Add derive for Debug, Clone, PartialEq on state types"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "This is the core architectural change. The state machine should make invalid states unrepresentable. Place in recorder/state.rs."
  },
  {
    "category": "functional",
    "description": "Create WriterGuard RAII struct for FFmpeg cleanup",
    "steps": [
      "Create WriterGuard struct with fields: ffmpeg_child, output_path, completed flag",
      "Implement Drop trait that kills FFmpeg and deletes partial file if not completed",
      "Add mark_completed() method to prevent cleanup on normal exit",
      "Refactor spawn_writer_thread to use WriterGuard",
      "Ensure guard is held throughout entire writer thread lifetime",
      "Test that partial files are deleted on panic/error"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read writer.rs first. The guard pattern ensures cleanup happens even on panic. FFmpeg child should be killed with SIGKILL if not completed."
  },
  {
    "category": "functional",
    "description": "Create CaptureGuard RAII struct for PipeWire cleanup",
    "steps": [
      "Create CaptureGuard struct that ensures mainloop quit and cleanup on drop",
      "Add event_tx field to send CaptureError on abnormal exit",
      "Implement Drop to log abnormal termination and notify coordinator",
      "Refactor run_capture_loop to use CaptureGuard",
      "Ensure PipeWire resources are released even on panic"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read stream.rs first. The guard should wrap the mainloop run and ensure proper cleanup sequence."
  },
  {
    "category": "functional",
    "description": "Move portal session to dedicated thread (eliminate unsafe transmute)",
    "steps": [
      "Create PortalSessionData struct with owned fields: pipewire_fd (OwnedFd), node_id (u32), resolution_hint",
      "Create spawn_portal_thread() function that runs portal in dedicated std::thread",
      "Create own tokio runtime inside portal thread for async operations",
      "Use oneshot channel to send PortalSessionData back to coordinator",
      "Use oneshot channel for close signal (session lives until signal received)",
      "Remove unsafe transmute from session.rs",
      "Create PortalHandle struct with close_tx and join_handle"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "This is critical for safety. The portal session has lifetime issues - by running it in a dedicated thread that OWNS the session, we eliminate the need for unsafe transmute. Read session.rs lines 145-146."
  },
  {
    "category": "functional",
    "description": "Implement bounded channels with timeout (deadlock prevention)",
    "steps": [
      "Replace std::sync::mpsc::sync_channel with crossbeam_channel::bounded",
      "Add crossbeam-channel dependency to Cargo.toml",
      "Create send_frame() helper that uses send_timeout(5s)",
      "Return CaptureError::WriterStalled on timeout",
      "Return CaptureError::WriterDisconnected on channel close",
      "Update stream.rs to use new channel pattern",
      "Remove channel_open AtomicBool (no longer needed with timeout)"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read stream.rs lines 128-209. The current pattern can deadlock if writer crashes. Timeout-based sends prevent this entirely."
  },
  {
    "category": "functional",
    "description": "Implement atomic token file persistence",
    "steps": [
      "Create TokenStore struct wrapping the token file path",
      "Implement save() using write-to-temp-then-rename pattern",
      "Ensure temp file uses .tmp extension",
      "Use std::fs::rename for atomic replacement (POSIX guarantee)",
      "Return Result<(), io::Error> instead of silently failing",
      "Refactor load_tokens/save_token/clear_token to use TokenStore",
      "Remove silent error swallowing (unwrap_or_default on parse)"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read tokens.rs. Current implementation has TOCTOU race conditions. Atomic rename is the standard solution."
  },
  {
    "category": "functional",
    "description": "Create RecordingCoordinator actor (single owner pattern)",
    "steps": [
      "Create RecordingCoordinator struct owning: state, event channels, handles (PortalHandle, CaptureHandle, WriterHandle)",
      "Implement run() async method with tokio::select! over event_rx and command_rx",
      "Implement handle_event() that calls state.transition() and executes side effects",
      "Implement execute_effect() for each SideEffect variant",
      "Ensure cleanup drops handles in correct order: writer -> capture -> portal",
      "Replace RecorderState (shared mutexes) with RecordingCoordinator (single owner)"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "This is the main architectural change. Read recorder/mod.rs and recorder/commands.rs. The coordinator OWNS all resources - no shared mutexes between threads."
  },
  {
    "category": "functional",
    "description": "Refactor Tauri commands to use RecordingCoordinator",
    "steps": [
      "Create command channel for IPC -> Coordinator communication",
      "Refactor recorder_start to send StartRequested command and await response",
      "Refactor recorder_stop to send StopRequested command and await response",
      "Refactor recorder_status to query coordinator state",
      "Remove direct RecorderState access from commands",
      "Update lib.rs to spawn coordinator task on startup"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read commands.rs. Commands should no longer manipulate state directly - they send messages to the coordinator."
  },
  {
    "category": "functional",
    "description": "Implement event-based frontend state sync",
    "steps": [
      "Emit 'quickclip:state-change' event on every state transition with full status",
      "Update useQuickClip.ts to use event listener as primary sync mechanism",
      "Remove 500ms polling interval (events are sufficient)",
      "Add 'quickclip:error' event for error notifications",
      "Include frame_count, elapsed_time, resolution in state-change payload",
      "Update QuickClipPlugin.tsx to handle new event structure"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read useQuickClip.ts. Current polling creates 500ms lag. Event-based sync is immediate and eliminates state divergence."
  },
  {
    "category": "functional",
    "description": "Replace all .unwrap() calls with proper error handling",
    "steps": [
      "Find all .lock().unwrap() calls in quickclip module",
      "Replace with .lock().expect('descriptive context') or handle poisoning",
      "Find all .expect() calls and ensure they have descriptive messages",
      "Remove Pod::from_bytes().expect() in stream.rs - use ? operator",
      "Remove timestamp .expect() in commands.rs - use ? with error conversion",
      "Ensure no panic paths remain in production code"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Project guidelines prohibit unwrap() in production code. Read CLAUDE.md for conventions. Use grep to find all instances."
  },
  {
    "category": "functional",
    "description": "Add PipeWire mainloop timeout mechanism",
    "steps": [
      "Add maximum recording duration constant (e.g., 4 hours)",
      "Create timeout check in the 100ms timer callback",
      "Force mainloop.quit() if maximum duration exceeded",
      "Return CaptureError::MainloopTimeout when triggered",
      "Emit appropriate error event to frontend"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Read stream.rs lines 291-312. Currently mainloop.run() has no escape if PipeWire hangs. The timer callback should enforce a hard limit."
  },
  {
    "category": "test",
    "description": "Add unit tests for RecordingState state machine",
    "steps": [
      "Test Idle + StartRequested -> Starting transition",
      "Test Starting + PortalReady -> Recording transition",
      "Test Recording + StopRequested -> Stopping transition",
      "Test any state + Error -> Failed transition with Cleanup effect",
      "Test invalid transitions are no-ops (no panic)",
      "Test all SideEffects are correctly produced"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "State machine is a pure function - trivial to unit test. No mocking required."
  },
  {
    "category": "test",
    "description": "Add unit tests for RAII guards",
    "steps": [
      "Test WriterGuard deletes partial file on drop when not completed",
      "Test WriterGuard preserves file when mark_completed() called",
      "Test WriterGuard kills FFmpeg process on abnormal drop",
      "Use tempfile crate for test file management",
      "Test CaptureGuard sends error event on abnormal drop"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Guards can be tested independently of the full recording flow. Use mock Child process if needed."
  },
  {
    "category": "test",
    "description": "Add unit tests for error recovery logic",
    "steps": [
      "Test PortalError::TokenInvalid.is_recoverable_with_retry() returns true",
      "Test PortalError::UserCancelled.is_recoverable_with_retry() returns false",
      "Test token retry logic clears token and retries once",
      "Test second failure after retry is not retried",
      "Test error type conversions work correctly (#[from])"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "Error handling is critical - ensure recovery paths work as expected."
  },
  {
    "category": "test",
    "description": "Add integration test for bounded channel timeout",
    "steps": [
      "Create test with bounded(1) channel",
      "Fill channel with one message",
      "Verify send_timeout returns Err after timeout",
      "Verify correct error variant (WriterStalled vs WriterDisconnected)",
      "Test channel disconnect detection"
    ],
    "shouldCommit": true,
    "passes": false,
    "notes": "This tests the deadlock prevention mechanism. Use short timeouts (10ms) in tests."
  },
  {
    "category": "test",
    "description": "Manual test: full recording flow with new architecture",
    "steps": [
      "Test start recording via UI",
      "Test stop recording via UI",
      "Test start recording via global shortcut",
      "Test stop recording via global shortcut",
      "Verify state events are emitted correctly",
      "Verify cleanup happens on error (kill FFmpeg mid-recording)",
      "Verify partial files are deleted on error"
    ],
    "shouldCommit": false,
    "passes": false,
    "notes": "Manual testing required after all architectural changes are complete. Test error paths by killing FFmpeg process manually."
  },
  {
    "category": "test",
    "description": "Manual test: verify no resource leaks",
    "steps": [
      "Start and stop recording 10 times",
      "Verify no orphaned FFmpeg processes (ps aux | grep ffmpeg)",
      "Verify no orphaned portal sessions (check D-Bus)",
      "Verify no memory growth in Jubby process",
      "Test error scenarios don't leak resources"
    ],
    "shouldCommit": false,
    "passes": false,
    "notes": "Resource leak testing requires monitoring system state. Use htop or similar for memory monitoring."
  }
]

QuickClip Plugin - Progress Tracker

Design: APPROVED (2026-01-16)
Design doc: docs/plans/2026-01-16-quickclip-design.md

Tasks:
[x] Research screen capture and video encoding on Linux/Tauri
[x] Create QuickClip plugin scaffold and manifest
[x] Implement Rust backend for screen capture
[x] Implement video encoding and storage
[ ] Implement clipboard integration for video
[ ] Implement global hotkey for recording toggle
[ ] Implement recording overlay window
[x] Build plugin UI - empty state and onboarding
[ ] Build plugin UI - recordings grid
[ ] Build plugin UI - settings screen
[ ] Implement recording metadata and persistence
[ ] Polish and edge cases

Current: Empty state and onboarding UI complete

---

## 2026-01-16 16:30 - Research Task

### What was implemented
Comprehensive research on technical feasibility of QuickClip plugin on Linux/Tauri.

### Research Findings

#### 1. Screen Capture Libraries for Rust

**Recommended: xcap (v0.8.1)**
- Cross-platform: Linux (X11, Wayland), macOS, Windows
- Uses PipeWire for Wayland support
- Video recording: WIP but functional for screen recording
- 886 stars, 163 commits, actively maintained (Jan 2026)
- Dependencies: `libxcb-dev libxrandr-dev libdbus-1-dev libpipewire-0.3-dev`

**Limitations:**
- Wayland support is partial ("not fully supported in some special scenarios")
- Window recording still "to be developed"
- Minimized windows cannot be captured

**Alternative: scap (CapSoftware)**
- High-performance, uses PipeWire on Linux
- Frame capture only, no video file output (need separate encoding)
- Still in beta (v0.1.0-beta.1)
- No audio capture support

#### 2. FFmpeg Integration

**Recommended: ffmpeg-sidecar**
- Wraps standalone FFmpeg binary with Rust Iterator interface
- Data moves via stdin/stdout pipes
- Progress reporting from stderr parsing
- Auto-download of FFmpeg binary at runtime
- Best for Tauri: bundle static binaries per platform

**Why CLI over bindings:**
- Avoids C API complexity and memory management issues
- Full FFmpeg codec/format support
- Easier cross-platform deployment
- ~100MB binary size when zipped

**Alternative: ffmpeg-next**
- Direct bindings, more control
- Higher complexity, FFI challenges
- Version compatibility concerns

#### 3. Clipboard Video Support on Linux

**Critical Finding: Limited support**

**Discord limitation:**
- Discord on Linux only accepts `image/png` MIME type for paste
- Video files CANNOT be pasted into Discord via clipboard
- Workaround: Drag-and-drop from file manager, or use upload dialog

**wl-copy capabilities:**
- Can copy arbitrary MIME types including `video/mp4`
- Use `wl-copy -t video/mp4 < video.mp4`
- Use `--fork` for persistence after process exits
- Can use `text/uri-list` with `file://` URIs

**Recommendation:**
- Auto-copy the file path to clipboard for quick access
- Provide "Open in file manager" action for drag-and-drop
- Show clear instructions about drag-and-drop workflow
- Consider integration with OS file picker

#### 4. Overlay Window Exclusion from Capture

**Tauri support:**
- `setContentProtected(true)` available in Tauri v2
- Config option: `"contentProtected": true`

**Linux reality:**
- GTK implementation depends on window manager
- No reliable Wayland protocol for desktop apps
- `weston-content-protection` protocol exists but designed for DRM/HDCP in closed systems
- On Wayland, screenshot permission is interactive (user must confirm)

**Practical approach:**
- Use `setContentProtected` (may work on some compositors)
- Position overlay at screen edge (easy to exclude manually if needed)
- Keep overlay minimal (small indicator dot)
- Consider overlay being captured acceptable (common in screen recorders)

### Learnings for future iterations

**Patterns discovered:**
- xcap is the go-to for Rust screen capture on Linux
- ffmpeg-sidecar is the standard for Tauri + FFmpeg integration
- Wayland security model prevents arbitrary window content access

**Gotchas encountered:**
- Discord paste limitation is fundamental - can't paste videos on Linux
- Wayland content protection is compositor-dependent
- PipeWire permission dialogs appear every time (user friction)

**Useful context:**
- For a personal tool, some limitations are acceptable
- Drag-and-drop workflow is common for video sharing on Linux
- Recording indicator being captured is industry standard (OBS, etc.)

### Technical Decision Summary

| Component | Choice | Risk Level |
|-----------|--------|------------|
| Screen Capture | xcap | Medium (Wayland partial) |
| Video Encoding | ffmpeg-sidecar + bundled binary | Low |
| Clipboard | wl-copy for path, drag-drop for Discord | Medium (UX friction) |
| Overlay | setContentProtected + accept capture risk | Low |

### Files changed
- ralph/progress.txt (this file)

### Next Steps
Ready to proceed with plugin scaffold (task 2). The research confirms the plugin is feasible with known limitations around clipboard video paste to Discord.

---

## 2026-01-16 - Create QuickClip plugin scaffold and manifest

### What was implemented
Created the foundational plugin scaffold following existing plugin patterns (todo, prompt-enhancer).

### Files changed
- `src/plugins/quickclip/index.tsx` - Plugin manifest with capabilities for screen-capture, global-shortcut, clipboard-video
- `src/plugins/quickclip/QuickClipPlugin.tsx` - Basic component with empty state UI showing hotkey hint and "Start Recording" button
- `src/plugins/quickclip/types.ts` - TypeScript interfaces for Recording, QuickClipSettings, CaptureMode, AudioMode, QualityMode
- `src/plugins/registry.ts` - Registered QuickClipManifest

### Learnings for future iterations

**Patterns discovered:**
- Plugin scaffold follows consistent structure: index.tsx (manifest), PluginName.tsx (component), types.ts (interfaces)
- useNavigationLevels() is required for breadcrumb integration
- Capabilities defined in manifest signal native feature requirements to the system

**Gotchas encountered:**
- cargo check must be run from src-tauri directory, not project root
- Icons must come from lucide-react per CLAUDE.md conventions

**Useful context:**
- Empty state component pattern: icon in muted circle + description + action button
- kbd element styling for keyboard shortcuts: `rounded bg-muted px-1.5 py-0.5 font-mono text-xs`

### Next Steps
Ready for Rust backend implementation (task 3: screen capture) or UI work (task 8: empty state and onboarding).

---

## 2026-01-16 - Implement Rust backend for screen capture

### What was implemented
Created the Rust capture module providing IPC commands for screen capture functionality using xcap library.

**IPC Commands:**
- `capture_get_sources` - Lists all monitors and windows available for capture
- `capture_monitor(monitor_id)` - Captures a specific monitor by ID
- `capture_window(window_id)` - Captures a specific window by ID
- `capture_primary` - Captures the primary monitor (or first available)

**Features:**
- Proper error handling with `thiserror` (no unwrap/panic in production code)
- Saves captured frames to `~/.local/share/jubby/quickclip/frames/`
- Returns structured response with path, dimensions, and timestamp
- Filters out minimized windows from source list
- Follows existing codebase patterns (camelCase serde, Result<T, String> IPC)

### Files changed
- `src-tauri/Cargo.toml` - Added xcap (0.0.14) and image (0.25) dependencies
- `src-tauri/src/capture.rs` - New module with capture logic and IPC commands
- `src-tauri/src/lib.rs` - Registered capture module and commands

### Learnings for future iterations

**Patterns discovered:**
- IPC commands return `Result<T, String>` where internal implementation uses proper error types
- Internal functions use `_internal` suffix pattern for separating IPC boundary from logic
- XDG directory handling should be consistent across modules (get_storage_dir pattern)

**Gotchas encountered:**
- xcap has a future-incompatibility warning but still compiles fine
- Window capture on Wayland may require PipeWire permissions (user will see portal dialog)
- Minimized windows cannot be captured (xcap limitation)

**Useful context:**
- Monitor IDs are strings (display connector names on Linux)
- Window IDs are u32 (X11 window IDs)
- Frame files use timestamp as filename: `frame_{timestamp}.png`

### Next Steps
Ready for video encoding (task 4) or frontend integration to test capture commands.

---

## 2026-01-16 - Implement video encoding and storage

### What was implemented
Created the Rust recorder module providing continuous frame capture and FFmpeg-based video encoding.

**IPC Commands:**
- `recorder_check_ffmpeg` - Verifies FFmpeg is installed on the system
- `recorder_start(monitor_id, quality, fps?)` - Starts recording a monitor, continuously capturing frames
- `recorder_stop` - Stops recording, encodes captured frames to MP4, generates thumbnail
- `recorder_status` - Returns current recording state (is_recording, frame_count, elapsed_seconds)
- `recorder_delete_video(video_path, thumbnail_path)` - Deletes a recording and its thumbnail

**Features:**
- Continuous frame capture at configurable FPS (default 30)
- Quality profiles: light (CRF 28, fast preset) and high (CRF 18, slower preset)
- FFmpeg CLI integration for encoding PNG sequences to H.264 MP4
- Automatic thumbnail generation from first frame (320px width)
- Session-based frame storage with automatic cleanup after encoding
- Proper async handling with spawn_blocking for encoding operations
- 5-minute encoding timeout to prevent hangs on long recordings

**Storage Structure:**
```
~/.local/share/jubby/quickclip/
├── sessions/     # Temporary frame storage during recording
├── videos/       # Final encoded MP4 files
└── thumbnails/   # Video thumbnails (PNG)
```

### Files changed
- `src-tauri/src/recorder.rs` - New module with recording, encoding, and thumbnail generation
- `src-tauri/src/lib.rs` - Registered recorder module, commands, and RecorderState

### Learnings for future iterations

**Patterns discovered:**
- Tauri state management requires Arc wrapping for fields that need cloning in async tasks
- FFmpeg CLI approach avoids Rust binding complexity while providing full codec support
- spawn_blocking + timeout pattern works well for CPU-intensive operations

**Gotchas encountered:**
- AtomicBool and Mutex don't implement Clone; need Arc wrappers for async task sharing
- FFmpeg frame input requires sequential numbering (frame_%06d.png pattern)
- ffprobe needed alongside ffmpeg for duration extraction

**Useful context:**
- CRF 28 produces ~25MB files suitable for Discord's 25MB limit
- CRF 18 produces higher quality but larger files (~2-3x size)
- Encoding timeout of 5 minutes should handle most reasonable recording lengths

### Next Steps
Ready for clipboard integration (task 5) or global hotkey (task 6).

---

## 2026-01-16 - Build plugin UI - empty state and onboarding

### What was implemented
Created a fully functional onboarding UI for QuickClip with a distinctive "broadcast studio" aesthetic featuring a large circular record button with animated states.

**Features:**
- Large circular record button with animated pulse effect when recording
- Real-time elapsed time display during recording (MM:SS format)
- Capture mode selector (currently fullscreen only, ready for window/region)
- Multi-monitor selector when more than one display is connected
- Hotkey hint displaying Ctrl+Shift+R shortcut with styled kbd elements
- FFmpeg availability check with helpful installation instructions if missing
- Loading states for preparation and encoding phases
- Smooth Motion animations for state transitions

**UI States:**
1. Loading - while checking FFmpeg availability
2. FFmpeg Warning - helpful installation guide with package manager command
3. Idle - record button with mode selector and hotkey hint
4. Preparing - spinner in button while initializing capture
5. Recording - pulsing button with live timer and stop icon
6. Encoding - "Encoding video..." message with spinner

### Files changed
- `src/plugins/quickclip/useQuickClip.ts` - New hook for recorder IPC commands (start/stop, status polling, FFmpeg check, source discovery)
- `src/plugins/quickclip/QuickClipPlugin.tsx` - Complete rewrite with new onboarding UI components

### Learnings for future iterations

**Patterns discovered:**
- Use `invoke` from `@tauri-apps/api/core` for IPC commands
- Poll status with `setInterval` during recording for live updates
- Use `motion/react` for smooth state transitions and animations
- Tailwind `tabular-nums` class for fixed-width number displays in timers

**Gotchas encountered:**
- Monitor `isPrimary` field uses camelCase in frontend due to Rust serde config
- Must check FFmpeg availability on mount before showing recording UI
- AnimatePresence requires `mode="wait"` for sequential exit/enter animations

**Useful context:**
- The record button uses a circular design (h-24 w-24) matching broadcast studio aesthetic
- Red color (#ef4444 / red-500) is consistently used for recording-related elements
- Hotkey hint uses styled kbd elements matching existing codebase patterns

### Next Steps
Ready for recordings grid UI (task 9) to display captured videos, or global hotkey implementation (task 6).

## 2026-01-16 - Task 1: Architecture - Criar modelo de dados AppSettings
- What was implemented:
  - Added `AppSettings` interface to `src/core/types.ts`
  - Added `DEFAULT_SETTINGS` constant with `globalShortcut: 'F9'`
  - Created `src-tauri/src/settings.rs` with `AppSettings` struct and `Default` trait
  - Registered settings module in `lib.rs`
- Files changed:
  - `src/core/types.ts` - Added AppSettings interface and DEFAULT_SETTINGS
  - `src-tauri/src/settings.rs` - New file with Rust AppSettings struct
  - `src-tauri/src/lib.rs` - Added settings module declaration
- **Learnings for future iterations:**
  - The codebase uses `camelCase` for JSON serialization in Rust (via serde rename_all)
  - Storage uses SQLite via rusqlite, not JSON files as originally documented
  - The storage module has a `get_storage_dir()` function that can be reused for settings

## 2026-01-16 - Task 2: Backend - Implementar persistência de settings no Rust
- What was implemented:
  - Added `SettingsError` enum using thiserror for proper error handling
  - Implemented `load_settings()` that reads from `~/.local/share/jubby/settings.json`
  - Implemented `save_settings()` that writes to the same file with pretty JSON
  - Uses `AppSettings::default()` (F9) as fallback if file doesn't exist or is corrupted
  - Added XDG Base Directory Specification support via `get_storage_dir()` helper
- Files changed:
  - `src-tauri/src/settings.rs` - Added load/save functions and error types
- **Learnings for future iterations:**
  - Settings use JSON file storage (separate from SQLite database used for app data)
  - `thiserror` crate is already available in Cargo.toml for custom errors
  - Functions are currently unused (will be connected in Task 3/4 for shortcut registration)
  - The `load_settings()` function intentionally returns default values on any error to ensure app always starts

## 2026-01-16 - Task 3: Backend - Implementar registro dinâmico de shortcut global
- What was implemented:
  - Added `parse_shortcut()` function that converts strings like "Ctrl+Shift+J" or "F9" to `Shortcut` using the `global_hotkey` crate's parser
  - Added `CurrentShortcut` state struct to track the currently registered shortcut string
  - Created `register_toggle_shortcut()` helper that registers a shortcut with the window toggle handler
  - Implemented `update_shortcut()` function that: unregisters current shortcut, parses and registers new one, updates state, and saves to settings
  - Added `get_settings` Tauri command that returns current `AppSettings`
  - Added `update_global_shortcut` Tauri command that updates the shortcut at runtime
  - Registered both commands in `lib.rs` invoke_handler
  - Added `CurrentShortcut` state management in setup
- Files changed:
  - `src-tauri/src/settings.rs` - Added parse_shortcut, CurrentShortcut, register_toggle_shortcut, update_shortcut, and Tauri commands
  - `src-tauri/src/lib.rs` - Added command registration and CurrentShortcut state
  - `src-tauri/Cargo.toml` - Added `global-hotkey = "0.7"` dependency for HotKeyParseError type
- **Learnings for future iterations:**
  - `tauri_plugin_global_shortcut` uses `global_hotkey::hotkey::HotKeyParseError` for parse errors
  - The `Shortcut` type implements `FromStr` trait, so `shortcut_str.parse()` works directly
  - `GlobalShortcutExt` trait provides `global_shortcut()` method on `AppHandle`
  - `on_shortcut()` registers a shortcut with a handler, `unregister()` removes it
  - Avoid generic `<R: Runtime>` when interfacing with non-generic code like `window::toggle`
  - `ShortcutState` already exists in the plugin, so named our state `CurrentShortcut` to avoid collision

## 2026-01-16 - Task 4: Backend - Modificar startup para carregar shortcut dinâmico
- What was implemented:
  - Modified `lib.rs` to load settings at startup using `load_settings()`
  - Parse shortcut string from settings using `parse_shortcut()`
  - Fallback to `Shortcut::new(None, Code::F9)` if parsing fails
  - Initialize `CurrentShortcut` state with the actual loaded shortcut string
  - Updated log messages to show the actual shortcut being registered
  - Changed setup closure to `move` to take ownership of `shortcut_str`
- Files changed:
  - `src-tauri/src/lib.rs` - Load settings at startup, dynamic shortcut registration
- **Learnings for future iterations:**
  - Closures passed to `.setup()` require `move` keyword when capturing variables from outer scope
  - The shortcut is registered before setup runs (in Builder chain), so settings must be loaded before Builder
  - Removed hardcoded `Code::F9` in favor of dynamic value from settings
  - App will always start even if settings are corrupted (uses F9 fallback)

## 2026-01-16 - Task 5: Frontend - Criar hook useSettings
- What was implemented:
  - Created `src/core/hooks/useSettings.ts`
  - Implemented settings loading via `invoke('get_settings')` in useEffect
  - Implemented `updateShortcut()` function that calls `invoke('update_global_shortcut')`
  - Returns `{ settings, isLoading, updateShortcut }` following the established pattern
  - Uses optimistic updates with rollback on error
  - Toast notifications for success and error states
- Files changed:
  - `src/core/hooks/useSettings.ts` - New file with useSettings hook
- **Learnings for future iterations:**
  - Follow the pattern in `useTodoStorage.ts` for hook structure: useState, useEffect for loading, useCallback for actions
  - Use optimistic updates: update local state first, then invoke backend, rollback on error
  - Import `invoke` from `@tauri-apps/api/core` (not `@tauri-apps/api`)
  - Toast is imported from `sonner` package
  - The hook returns a boolean from `updateShortcut` to indicate success/failure to the caller

## 2026-01-16 - Task 6: Frontend - Criar componente ShortcutCapture
- What was implemented:
  - Created `src/core/components/Settings/ShortcutCapture.tsx`
  - Implemented `isCapturing` state that enables keydown listener when active
  - Built shortcut string from `event.ctrlKey`, `shiftKey`, `altKey`, `metaKey` + `event.code`
  - Created `codeToKeyName()` helper to convert event.code to readable key names (e.g., KeyA → A, F9 → F9)
  - Validates that shortcut has at least one non-modifier key (ignores modifier-only presses)
  - Blocks invalid keys like Escape alone
  - Calls `onChange` with captured shortcut and exits capture mode
  - Window blur handler exits capture mode (user clicked away)
- Files changed:
  - `src/core/components/Settings/ShortcutCapture.tsx` - New file with ShortcutCapture component
- **Learnings for future iterations:**
  - Use `event.code` (not `event.key`) for consistency across keyboard layouts
  - Modifier keys: ControlLeft/Right, ShiftLeft/Right, AltLeft/Right, MetaLeft/Right
  - Use `{ capture: true }` (third arg `true`) on addEventListener to capture events before other handlers
  - The component follows the pattern of other components: button-based with visual state for capturing mode
  - Tauri global_shortcut uses "Ctrl", "Alt", "Shift", "Super" for modifiers (not "Control" or "Meta")

## 2026-01-16 - Task 7: Frontend - Criar view Settings
- What was implemented:
  - Created `src/core/components/Settings/Settings.tsx`
  - Used `PluginHeader` with title "Configurações" and Settings icon from lucide
  - Rendered "Atalho Global" section with `ShortcutCapture` component
  - Used `useSettings` hook to load and update settings
  - Implemented loading state with spinner (same pattern as TodoPlugin)
  - Created `SettingsSection` mini-component for section headers
  - Created `SettingsRow` mini-component for label/description + control layout
- Files changed:
  - `src/core/components/Settings/Settings.tsx` - New file with Settings view
- **Learnings for future iterations:**
  - Follow the existing plugin pattern: PluginHeader at top, content in flex column with padding
  - Mini-components defined in same file per CLAUDE.md conventions
  - Toast success is already handled by useSettings hook, no need to duplicate
  - Settings component takes `onBack` prop (not `onExitPlugin` like plugins) since it's not a plugin

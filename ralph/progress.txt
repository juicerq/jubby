# Tasks Plugin - PRD Automation Feature

## Current Status
Task 7 of 19 completed

## Tasks
- [x] 1. Backend - Update data model types
- [x] 2. Backend - Data migration
- [x] 3. Backend - CRUD commands for new fields
- [x] 4. Backend - OpenCode server management
- [x] 5. Backend - Execution orchestration command
- [x] 6. Frontend - Update useTasksStorage hook with new types
- [x] 7. Frontend - Update useTasksStorage hook with execution functions
- [ ] 8. Frontend - Task creation flow update
- [ ] 9. Frontend - Subtask expandable component
- [ ] 10. Frontend - Running state animation
- [ ] 11. Frontend - Run/Stop button logic
- [ ] 12. Frontend - Loop (Run All) button
- [ ] 13. Frontend - Drag to reorder subtasks
- [ ] 14. Frontend - History section
- [ ] 15. Frontend - Execution log detail view in subtask
- [ ] 16. Frontend - OpenCode server lifecycle
- [ ] 17. Frontend - AI Generate subtasks feature
- [ ] 18. Backend - AI Generate subtasks command
- [ ] 19. Manual testing - Full flow verification

## Notes
- Tasks 8, 9, 10, 11, 14, 15, 17 should use the frontend-design skill
- No borders between sections, use headers as separators
- Neon border animation: white/gray gradient rotating around border
- Server starts lazily when entering Tasks plugin
- Each subtask execution creates a new opencode session
- AI edits JSON directly, path passed in prompt
- Learnings from all previous executions included in prompt

## Design Decisions Summary
- Task = PRD (name, description, workingDirectory, subtasks)
- Subtask = PRD item (steps, category, shouldCommit, notes, executionLogs)
- Expand subtask with animation to see all details
- Run/Stop per subtask, Run All for loop
- One execution at a time, others disabled
- History: inline in subtask + aggregated section at bottom
- OpenCode Server API on port 4096
- Migration: automatic, preserves old data

---

## 2026-01-21 15:17 - Task 1: Backend - Update data model types

### What was implemented
- Added `TaskStatus` enum (waiting, in_progress, completed) for subtask status
- Added `SubtaskCategory` enum (functional, test) for categorizing subtasks
- Added `ExecutionOutcome` enum (success, partial, failed, aborted) for execution results
- Created `Step` struct (id, text, completed) for subtask checklist items
- Created `Learnings` struct with patterns/gotchas/context vectors
- Created `ExecutionLog` struct with all fields (id, startedAt, completedAt, duration, outcome, summary, filesChanged, learnings, committed, commitHash, commitMessage, errorMessage)
- Updated `Subtask` struct with new fields: status, order, category, steps, shouldCommit, notes, executionLogs
- Added legacy fields (completed, position) as Option with skip_serializing for migration compatibility
- Updated `Task` struct with description and workingDirectory fields
- Updated `TaskWithTags` response struct to include new Task fields
- Fixed all usages in commands.rs: subtasks_create, subtasks_toggle, subtasks_reorder, tasks_update_status cascade
- Fixed SQLite migration in storage.rs to include new Task fields

### Files changed
- `src-tauri/src/plugins/tasks/types.rs`
- `src-tauri/src/plugins/tasks/commands.rs`
- `src-tauri/src/plugins/tasks/storage.rs`

### Learnings for future iterations
- **Patterns discovered:**
  - All types use `#[serde(rename_all = "camelCase")]` for JS interop
  - Use `#[serde(default)]` for new fields to maintain backward compatibility
  - Use `#[serde(skip_serializing)]` for deprecated fields that should be read but not written
  - Enums use `#[serde(rename_all = "snake_case")]` for serialization
- **Gotchas encountered:**
  - When changing a field type (e.g., bool → enum), need to update all usages in commands.rs
  - SQLite migration also constructs Task manually, needs updating when Task fields change
  - TaskWithTags is a separate response struct that duplicates Task fields - must update both
- **Useful context:**
  - Subtask creation is in `subtasks_create` command at line ~384
  - Subtask toggle (now status change) is in `subtasks_toggle` command at line ~423
  - Task cascade (mark all subtasks complete) is in `tasks_update_status` command at line ~210

## 2026-01-21 15:18 - Task 2: Backend - Data migration

### What was implemented
- Created `migrate_subtask_data` function in storage.rs
- Migration logic: detects old format via `completed: Option<bool>` field presence
- Converts `completed: true` → `status: TaskStatus::Completed`, else `TaskStatus::Waiting`
- Converts `position: Option<i32>` → `order: u32`, falling back to array index
- Integrated into `load_or_migrate` flow - migrates on load from all sources (JSON, old todo.json)
- Saves migrated data immediately after migration for persistence
- Migration is idempotent: legacy fields use `skip_serializing` so they don't appear in output

### Files changed
- `src-tauri/src/plugins/tasks/storage.rs`

### Learnings for future iterations
- **Patterns discovered:**
  - Using `Option::take()` is idiomatic for detecting and consuming legacy fields
  - Migration in `load_or_migrate` (not `load_from_json`) allows unified handling across all data sources
  - The `#[serde(default, skip_serializing)]` pattern makes migrations transparent: old data deserializes, new data doesn't include legacy fields
- **Gotchas encountered:**
  - Must save migrated data immediately, otherwise migration runs on every load (performance hit + log spam)
  - The `order` field defaults to 0, so we need to check `index > 0` to avoid false positives for first items
- **Useful context:**
  - Data paths: `~/.local/share/jubby/tasks/tasks.json` (current), `~/.local/share/jubby/todo/todo.json` (legacy)
  - `load_or_migrate` is the single entry point for all data loading in the tasks plugin

## 2026-01-21 15:22 - Task 3: Backend - CRUD commands for new fields

### What was implemented
- `tasks_update_description`: Updates task.description field
- `tasks_update_working_directory`: Updates task.workingDirectory with path existence and directory validation
- `subtasks_update_status`: Updates subtask.status enum (waiting/in_progress/completed)
- `subtasks_update_order`: Updates subtask.order for drag reorder
- `subtasks_update_category`: Updates subtask.category enum (functional/test)
- `subtasks_update_notes`: Updates subtask.notes field
- `subtasks_update_should_commit`: Toggles subtask.shouldCommit boolean
- `steps_create`: Creates a new Step in a subtask's steps array
- `steps_toggle`: Toggles step.completed boolean
- `steps_delete`: Removes a step from subtask.steps
- `steps_update_text`: Updates step.text
- `execution_logs_create`: Creates a new ExecutionLog with all fields (outcome, summary, filesChanged, learnings, commit info)
- Registered all 12 new commands in lib.rs invoke_handler

### Files changed
- `src-tauri/src/plugins/tasks/commands.rs`
- `src-tauri/src/lib.rs`

### Learnings for future iterations
- **Patterns discovered:**
  - All commands follow same pattern: validate input → get write lock → find entity (task → subtask → step) → update → save_to_json
  - Enum parameters come as strings from frontend, must be parsed with match statement and explicit error for invalid values
  - Path validation for workingDirectory: check exists() AND is_dir() - a file path passing exists() would be wrong
- **Gotchas encountered:**
  - Commands need to be registered in lib.rs invoke_handler - easy to forget
  - For nested entities (steps inside subtasks inside tasks), need multiple find() calls chained
  - execution_logs_create has many parameters - consider using a struct input in future for cleaner API
- **Useful context:**
  - New commands start at line ~550 in commands.rs
  - Commands are registered at lines ~127-140 in lib.rs (tasks plugin section)
  - Frontend will need corresponding invoke() calls with exact parameter names (camelCase from Rust snake_case)

## 2026-01-21 15:24 - Task 6: Frontend - Update useTasksStorage hook with new types

### What was implemented
- Updated `types.ts` with all new types matching backend:
  - `SubtaskStatus` enum (waiting, in_progress, completed)
  - `SubtaskCategory` enum (functional, test)
  - `ExecutionOutcome` enum (success, partial, failed, aborted)
  - `Step` interface (id, text, completed)
  - `Learnings` interface (patterns, gotchas, context)
  - `ExecutionLog` interface (full execution log with all fields)
  - Updated `Subtask` interface: replaced `completed: boolean` with `status: SubtaskStatus`, added order, category, steps, shouldCommit, notes, executionLogs
  - Updated `Task` interface: added description, workingDirectory
- Updated `useTasksStorage.ts`:
  - Added backend interfaces for Step, Learnings, ExecutionLog, Subtask, Task
  - Added mapping functions: mapBackendStep, mapBackendLearnings, mapBackendExecutionLog
  - Updated mapBackendSubtask and mapBackendTask for new fields
  - Added helper functions: createDefaultSubtask, createDefaultTask
  - Added new functions: updateTaskDescription, updateTaskWorkingDirectory
  - Added subtask functions: updateSubtaskStatus, updateSubtaskOrder, updateSubtaskCategory, updateSubtaskNotes, updateSubtaskShouldCommit
  - Added step functions: createStep, toggleStep, deleteStep, updateStepText
  - Added createExecutionLog function
  - Updated UseTasksStorageReturn interface with all 27 functions
- Updated `TasksPlugin.tsx`:
  - Replaced `toggleSubtask` with `updateSubtaskStatus` throughout component chain
  - Changed `subtask.completed` to `subtask.status === "completed"` in all UI logic
  - Updated TasksPluginSubtaskList and TasksPluginSubtaskItem interfaces
  - Added local `isCompleted` and `handleToggle` for cleaner toggle logic
- Updated `TasksPluginTaskDetail.tsx`:
  - Changed prop interface from onToggleSubtask to onUpdateSubtaskStatus with SubtaskStatus parameter

### Files changed
- `src/plugins/tasks/types.ts`
- `src/plugins/tasks/useTasksStorage.ts`
- `src/plugins/tasks/TasksPlugin.tsx`
- `src/plugins/tasks/TasksPluginTaskDetail.tsx`

### Learnings for future iterations
- **Patterns discovered:**
  - Frontend interfaces mirror backend types with camelCase (JS convention)
  - Backend interfaces use `FromBackend` suffix to distinguish raw API data from mapped domain types
  - All CRUD functions follow optimistic update pattern: update state → invoke backend → rollback on error
  - Helper functions (createDefaultSubtask, createDefaultTask) centralize default values
- **Gotchas encountered:**
  - Changing `completed: boolean` to `status: enum` requires updating entire prop chain (TasksPlugin → TasksPluginSubtaskList → TasksPluginSubtaskItem)
  - Ghost components (TasksPluginSubtaskGhost) also reference subtask fields, easy to miss
  - The status toggle logic (waiting ↔ completed) is different from simple boolean flip
- **Useful context:**
  - Type imports from types.ts are in lines 27-35 of TasksPlugin.tsx
  - UseTasksStorageReturn interface documents all available functions
  - TasksPluginTaskDetail is in a separate file and imports SubtaskStatus for its prop interface

## 2026-01-21 15:31 - Task 4: Backend - OpenCode server management

### What was implemented
- Created `src-tauri/src/plugins/tasks/opencode.rs` module with full OpenCode server HTTP API integration
- `OpenCodeServerState` struct for tracking server process PID (RwLock for thread safety)
- `opencode_ensure_server`: Checks if server is running on port 4096, spawns `opencode serve` if not, polls until ready (max 10s)
- `opencode_health_check`: GET `/global/health` - returns `{healthy: bool, version: string}`
- `opencode_create_session`: POST `/session` - creates new session with optional title
- `opencode_send_prompt`: POST `/session/{id}/prompt_async` - sends prompt asynchronously with optional agent
- `opencode_poll_status`: GET `/session/status` - polls all sessions status, returns status for specific session
- `opencode_abort_session`: POST `/session/{id}/abort` - aborts running session
- `opencode_stop_server`: Sends SIGTERM to server process if started by this app
- Added `reqwest` dependency for HTTP client
- Registered all 7 commands in lib.rs invoke_handler
- Registered `OpenCodeServerState` in app setup

### Files changed
- `src-tauri/src/plugins/tasks/opencode.rs` (new file)
- `src-tauri/src/plugins/tasks/mod.rs` (added module export)
- `src-tauri/src/lib.rs` (registered commands and state)
- `src-tauri/Cargo.toml` (added reqwest dependency)

### Learnings for future iterations
- **Patterns discovered:**
  - OpenCode server API uses `/global/health` not `/health`
  - Session status endpoint returns HashMap<sessionId, status> for all sessions, not single session
  - Use `prompt_async` endpoint for non-blocking prompt sending (returns 204 immediately)
  - Server spawning uses tokio::process::Command for async compatibility
- **Gotchas encountered:**
  - Health response has `healthy: bool` and `version: string`, not `status: string`
  - Session creation request body is minimal (just optional title), not path-based
  - Status types are "idle", "busy", "retry" (not "error")
  - The kill command needs `.status()` not `.exec()` to actually run
- **Useful context:**
  - OpenCode server runs on port 4096 by default
  - All request/response types use camelCase via `#[serde(rename_all = "camelCase")]`
  - State management uses tauri's `State` wrapper with `app.manage()` in setup
  - Commands registered in lib.rs around line 140 (tasks plugin section)

## 2026-01-21 15:37 - Task 5: Backend - Execution orchestration command

### What was implemented
- Added `tasks_execute_subtask` command in opencode.rs that orchestrates full subtask execution
- Command parameters: `taskId`, `subtaskId`
- Execution flow:
  1. Ensures OpenCode server is running (auto-starts if not)
  2. Retrieves task and subtask data from TasksStore
  3. Validates workingDirectory is set
  4. Builds prompt with PRD file references (@path/prd.json @path/progress.txt)
  5. Creates OpenCode session with descriptive title (task: subtask)
  6. Sends prompt asynchronously
  7. Polls session status until "idle" (success) or timeout (5 min)
- Added `ExecutionResult` struct for command response (sessionId, outcome, aborted, errorMessage)
- Added `build_execution_prompt` helper function that generates the standard PRD execution prompt
- Registered command in lib.rs invoke_handler

### Files changed
- `src-tauri/src/plugins/tasks/opencode.rs`
- `src-tauri/src/lib.rs`

### Learnings for future iterations
- **Patterns discovered:**
  - Commands that need multiple State types can take them as separate parameters (store, server_state)
  - Clone task/subtask data out of the read lock scope to avoid holding lock during async operations
  - Polling loop with timeout pattern: `let start = Instant::now(); loop { if start.elapsed() > timeout { break; } }`
- **Gotchas encountered:**
  - Must validate workingDirectory before building prompt - empty path causes invalid file references
  - Session status "idle" means complete, not "success" - OpenCode uses this terminology
  - The prompt references files relative to workingDirectory, not absolute paths
- **Useful context:**
  - Execution timeout is 5 minutes (EXECUTION_TIMEOUT_SECS = 300)
  - Poll interval is 500ms (POLL_INTERVAL)
  - The prompt template instructs AI to work on highest priority task and update progress.txt
  - Frontend will call this command and handle the ExecutionResult to create ExecutionLog entries

## 2026-01-21 15:40 - Task 7: Frontend - Update useTasksStorage hook with execution functions

### What was implemented
- Added `ExecutionResultFromBackend` interface matching backend ExecutionResult struct
- Added execution state to hook: `isExecuting`, `executingSubtaskId`, `currentSessionIdRef` (using useRef to avoid stale closures)
- Added `ensureOpenCodeServer()` function: calls `opencode_ensure_server` backend command
- Added `executeSubtask(taskId, subtaskId)` function: invokes `tasks_execute_subtask`, manages execution state (sets isExecuting/executingSubtaskId before, clears in finally block), returns ExecutionResultFromBackend
- Added `abortExecution()` function: calls `opencode_abort_session` with current session ID from ref
- Updated `UseTasksStorageReturn` interface with all execution-related state and functions
- Added `useRef` import from React

### Files changed
- `src/plugins/tasks/useTasksStorage.ts`

### Learnings for future iterations
- **Patterns discovered:**
  - Using `useRef` for session ID avoids stale closure issues in async callbacks (state captured at callback creation time would be stale)
  - Execution state follows pattern: set before try → clear in finally → this ensures state is always reset even on error
  - Backend returns camelCase (sessionId, errorMessage) thanks to serde rename_all
- **Gotchas encountered:**
  - The `currentSessionId` in return object needs `.current` since it's a ref, but TypeScript interface expects string | null (works because ref.current is the value)
  - Must guard `executeSubtask` with `isExecuting` check to prevent concurrent executions
- **Useful context:**
  - Execution functions are at lines 1090-1146 in useTasksStorage.ts
  - The hook now exports 30 functions total (27 CRUD + 3 execution)
  - UI components can use `executingSubtaskId` to show running state per-subtask

## 2026-01-16 - Task 1: Architecture - Criar modelo de dados AppSettings
- What was implemented:
  - Added `AppSettings` interface to `src/core/types.ts`
  - Added `DEFAULT_SETTINGS` constant with `globalShortcut: 'F9'`
  - Created `src-tauri/src/settings.rs` with `AppSettings` struct and `Default` trait
  - Registered settings module in `lib.rs`
- Files changed:
  - `src/core/types.ts` - Added AppSettings interface and DEFAULT_SETTINGS
  - `src-tauri/src/settings.rs` - New file with Rust AppSettings struct
  - `src-tauri/src/lib.rs` - Added settings module declaration
- **Learnings for future iterations:**
  - The codebase uses `camelCase` for JSON serialization in Rust (via serde rename_all)
  - Storage uses SQLite via rusqlite, not JSON files as originally documented
  - The storage module has a `get_storage_dir()` function that can be reused for settings

## 2026-01-16 - Task 2: Backend - Implementar persistência de settings no Rust
- What was implemented:
  - Added `SettingsError` enum using thiserror for proper error handling
  - Implemented `load_settings()` that reads from `~/.local/share/jubby/settings.json`
  - Implemented `save_settings()` that writes to the same file with pretty JSON
  - Uses `AppSettings::default()` (F9) as fallback if file doesn't exist or is corrupted
  - Added XDG Base Directory Specification support via `get_storage_dir()` helper
- Files changed:
  - `src-tauri/src/settings.rs` - Added load/save functions and error types
- **Learnings for future iterations:**
  - Settings use JSON file storage (separate from SQLite database used for app data)
  - `thiserror` crate is already available in Cargo.toml for custom errors
  - Functions are currently unused (will be connected in Task 3/4 for shortcut registration)
  - The `load_settings()` function intentionally returns default values on any error to ensure app always starts

## 2026-01-16 - Task 3: Backend - Implementar registro dinâmico de shortcut global
- What was implemented:
  - Added `parse_shortcut()` function that converts strings like "Ctrl+Shift+J" or "F9" to `Shortcut` using the `global_hotkey` crate's parser
  - Added `CurrentShortcut` state struct to track the currently registered shortcut string
  - Created `register_toggle_shortcut()` helper that registers a shortcut with the window toggle handler
  - Implemented `update_shortcut()` function that: unregisters current shortcut, parses and registers new one, updates state, and saves to settings
  - Added `get_settings` Tauri command that returns current `AppSettings`
  - Added `update_global_shortcut` Tauri command that updates the shortcut at runtime
  - Registered both commands in `lib.rs` invoke_handler
  - Added `CurrentShortcut` state management in setup
- Files changed:
  - `src-tauri/src/settings.rs` - Added parse_shortcut, CurrentShortcut, register_toggle_shortcut, update_shortcut, and Tauri commands
  - `src-tauri/src/lib.rs` - Added command registration and CurrentShortcut state
  - `src-tauri/Cargo.toml` - Added `global-hotkey = "0.7"` dependency for HotKeyParseError type
- **Learnings for future iterations:**
  - `tauri_plugin_global_shortcut` uses `global_hotkey::hotkey::HotKeyParseError` for parse errors
  - The `Shortcut` type implements `FromStr` trait, so `shortcut_str.parse()` works directly
  - `GlobalShortcutExt` trait provides `global_shortcut()` method on `AppHandle`
  - `on_shortcut()` registers a shortcut with a handler, `unregister()` removes it
  - Avoid generic `<R: Runtime>` when interfacing with non-generic code like `window::toggle`
  - `ShortcutState` already exists in the plugin, so named our state `CurrentShortcut` to avoid collision

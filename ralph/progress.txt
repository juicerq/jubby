# Contextual Logging System - PRD

## Current Status
Task 7 of 16 completed

## Tasks
- [x] 1. Rust - Create tracing types and data structures
- [x] 2. Rust - Implement LogWriter with buffered channel
- [x] 3. Rust - Implement ContextGuard with RAII
- [x] 4. Rust - Implement Trace struct core
- [x] 5. Rust - Implement Trace context methods
- [x] 6. Rust - Implement Trace logging methods
- [x] 7. Rust - Implement Trace Drop for trace_end
- [ ] 8. Rust - Implement cleanup for old logs
- [ ] 9. Rust - Create mod.rs and init_tracing()
- [ ] 10. Rust - Add required dependencies
- [ ] 11. Rust - Integration test with existing command
- [ ] 12. TypeScript - Create trace types
- [ ] 13. TypeScript - Implement createTrace and Trace class
- [ ] 14. TypeScript - Add trace propagation to invoke wrapper
- [ ] 15. TypeScript - Integration test with existing component
- [ ] 16. Manual testing - Full flow verification

## Architecture Summary

### Core Concept
Contextual logging where logs accumulate context as code executes. Context is added via `trace.push({ key: value })` and removed automatically via RAII guards.

### Key Decisions
- **Scope**: Stack-based with RAII (context auto-removed when guard drops)
- **Propagation**: Explicit `Arc<Trace>` parameter passing (async-safe)
- **Emission**: Logs anytime + automatic trace_end summary on Drop
- **Storage**: JSON-lines files (one per day: `YYYY-MM-DD.jsonl`)
- **Retention**: 1 day (cleanup on app startup)
- **Trace ID**: 8 hex chars (e.g., `a3f8b2c1`)
- **Error detail**: Medium (message + code, no backtrace)
- **Granularity**: One trace per Tauri command

### File Structure
```
src-tauri/src/tracing/
├── mod.rs        # pub use, init_tracing(), get_writer()
├── types.rs      # LogLevel, LogEntry, TraceError
├── trace.rs      # Trace struct, push/pop, log methods
├── guard.rs      # ContextGuard with Drop
├── writer.rs     # LogWriter with buffered channel
└── cleanup.rs    # cleanup_old_traces()

src/lib/
└── trace.ts      # createTrace(), Trace class
```

### Log Format (JSON-lines)
```jsonl
{"ts":"2026-01-21T14:32:01.123Z","trace":"a3f8b2c1","level":"info","msg":"Recording started","ctx":{"plugin":"quickclip"}}
{"ts":"2026-01-21T14:32:01.456Z","trace":"a3f8b2c1","level":"error","msg":"FFmpeg failed","ctx":{"plugin":"quickclip","stage":"encode"},"err":{"message":"Process exited","code":"FFMPEG_EXIT"}}
{"ts":"2026-01-21T14:32:01.457Z","trace":"a3f8b2c1","level":"trace_end","duration_ms":334,"status":"error","ctx":{"plugin":"quickclip"}}
```

### Writer Architecture
```
Trace 1 ──┐
          │   ┌─────────────┐     ┌─────────────────────┐
Trace 2 ──┼──▶│ Log Channel │────▶│ Writer Thread       │
          │   │ (mpsc)      │     │ - buffer 32 entries │
Trace 3 ──┘   └─────────────┘     │ - flush every 100ms │
                                  └──────────┬──────────┘
                                             │
                                             ▼
                                   YYYY-MM-DD.jsonl
```

---

## 2026-01-21 - Task 5: Rust - Implement Trace context methods
- Implemented `push(self: &Arc<Self>, ctx: Value) -> ContextGuard` method that adds context to stack and returns RAII guard
- Implemented `merged_context(&self) -> Value` that merges all context stack entries into single object (later values override earlier keys)
- Added Arc import and ContextGuard import to trace.rs
- Files changed: `src-tauri/src/traces/trace.rs`
- **Learnings for future iterations:**
  - Tasks 1-4 were already implemented in previous sessions but progress.txt wasn't updated
  - The `push()` method requires `&Arc<Self>` receiver to create the ContextGuard with a cloned Arc
  - Context merging iterates through stack in order, so later pushes naturally override earlier ones for same keys

## 2026-01-21 - Task 6: Rust - Implement Trace logging methods
- Implemented `emit(&self, level, msg, err)` internal method that creates LogEntry and sends via channel
- Uses `chrono::Utc::now().to_rfc3339_opts(SecondsFormat::Millis, true)` for ISO 8601 timestamps
- Sets `has_error` AtomicBool to true when error is present
- Fire-and-forget pattern: ignores send errors (writer may have shut down)
- Implemented convenience methods: `debug(&self, msg)`, `info(&self, msg)`, `warn(&self, msg)`
- Implemented `error(&self, msg, err: TraceError)` that wraps emit with LogLevel::Error
- Added imports: `AtomicBool::Ordering`, `chrono::{SecondsFormat, Utc}`, `LogLevel`, `TraceError`
- Files changed: `src-tauri/src/traces/trace.rs`
- **Learnings for future iterations:**
  - Cargo.toml must be in current directory for `cargo check` - run from src-tauri/
  - The 20 "unused" warnings are expected since the tracing module isn't integrated yet (task 9 & 11)
  - chrono's `to_rfc3339_opts` with `SecondsFormat::Millis` and `true` for Z suffix gives compact ISO format

## 2026-01-21 19:28 - Task 7: Rust - Implement Trace Drop for trace_end
- Implemented `Drop` trait for `Trace` struct
- On drop: calculates `duration_ms` from `started_at.elapsed().as_millis()`
- Determines status: "error" if `has_error` is true, "ok" otherwise
- Emits `LogLevel::TraceEnd` entry with `duration_ms` and `status` fields populated
- Uses same fire-and-forget pattern as other emit calls
- Files changed: `src-tauri/src/traces/trace.rs`
- **Learnings for future iterations:**
  - Drop trait ensures trace_end is emitted even if code panics (Drop still runs)
  - Empty `msg` string for trace_end is fine - the level itself communicates intent
  - `as_millis()` returns u128, cast to u64 is safe for durations under ~584 million years

# PipeWire Screen Capture - Progress Tracker

## Current Status: In Progress

## Tasks

- [x] Add PipeWire dependencies to Cargo.toml
- [x] Add new error variants to RecorderError
- [x] Create pipewire_capture module with portal integration
- [x] Implement PipeWire stream frame capture
- [ ] Refactor recorder.rs to use pipewire_capture
- [ ] Update frontend with capture mode buttons
- [ ] Manual verification of PipeWire capture

## Notes

Target: Replace xcap (~3fps) with PipeWire (~60fps) on Wayland.

---

## 2026-01-17 - Add PipeWire Dependencies

- **What was implemented:** Added PipeWire dependencies to Cargo.toml for Wayland screen capture
- **Files changed:**
  - `src-tauri/Cargo.toml` - Added ashpd v0.11 (with tokio feature), pipewire v0.8, and libspa v0.8
- **Learnings for future iterations:**
  - ashpd v0.10 has compatibility issues with zbus; use v0.11+ for proper zbus 5.x support
  - ashpd requires the `tokio` feature to work with Tauri's async runtime
  - libspa is required alongside pipewire for SPA buffer handling

## 2026-01-17 - Add Error Variants for PipeWire

- **What was implemented:** Added three new error variants to RecorderError for PipeWire capture
- **Files changed:**
  - `src-tauri/src/recorder.rs` - Added PortalUnavailable, UserCancelled, and PipeWireError variants
- **Learnings for future iterations:**
  - PortalUnavailable: for when XDG Desktop Portal is not running or unavailable
  - UserCancelled: for graceful handling when user cancels screen/area selection (should not show error toast)
  - PipeWireError(String): for generic PipeWire stream errors with context

## 2026-01-17 - Create pipewire_capture Module

- **What was implemented:** Created pipewire_capture.rs module with XDG Desktop Portal integration via ashpd
- **Files changed:**
  - `src-tauri/src/pipewire_capture.rs` - New module with ScreencastSession struct and portal integration
  - `src-tauri/src/lib.rs` - Added `mod pipewire_capture` declaration
- **Key features:**
  - `CaptureSource` enum with Fullscreen and Area variants
  - `ScreencastSession::new()` async method that:
    - Creates Screencast proxy via ashpd
    - Creates portal session
    - Selects sources (Monitor type, with cursor embedded)
    - Starts session and retrieves stream info
    - Opens PipeWire remote and returns file descriptor
  - Returns `pipewire_fd`, `node_id`, and optional `size` for PipeWire stream connection
  - Comprehensive logging at each step with `[CAPTURE]` prefix
  - Proper error handling mapping to RecorderError variants
- **Learnings for future iterations:**
  - `PersistMode` is in `ashpd::desktop`, not `ashpd::desktop::screencast`
  - `SourceType` must be converted to `BitFlags` using `.into()` when passed to `select_sources()`
  - Session lifetime requires unsafe transmute to 'static for storage in struct
  - Portal handles area selection UI - we just pass `multiple=true` for Area mode

## 2026-01-17 - Implement PipeWire Stream Frame Capture

- **What was implemented:** Added PipeWire stream capture functionality to pipewire_capture.rs
- **Files changed:**
  - `src-tauri/src/pipewire_capture.rs` - Added `run_capture_loop()` function and supporting types
- **Key features:**
  - `CaptureState` struct to hold frames, format info, and capture statistics
  - `CaptureResult` struct returned with frames, dimensions, and frame count
  - `run_capture_loop()` function that:
    - Initializes PipeWire with `pw::init()`
    - Creates MainLoop and Context
    - Connects to PipeWire using portal-provided fd via `context.connect_fd()`
    - Creates Stream with Video/Capture/Screen properties
    - Registers `param_changed` callback to parse VideoInfoRaw format
    - Registers `process` callback to dequeue buffers and store frame data
    - Handles memory limit (1.5GB) with auto-stop
    - Logs every 30th frame to avoid spam
  - `convert_bgrx_to_rgba()` helper for pixel format conversion
  - Video format negotiation with BGRx (preferred), RGBA, RGBx, RGB options
- **Learnings for future iterations:**
  - `Context::new()` requires `&MainLoop`, not `&LoopRef`
  - Object must be wrapped in `Value::Object(obj)` before serializing with `PodSerializer`
  - `data.chunk()` returns `&Chunk` directly, not `Option<&Chunk>`
  - Stream type aliasing required: `Stream as PortalStream` to avoid conflict with `pipewire::stream::Stream`
  - Format params built with `object!` macro then serialized via `PodSerializer::serialize()`
  - Memory mapped buffers via `StreamFlags::MAP_BUFFERS` - no manual mmap needed
